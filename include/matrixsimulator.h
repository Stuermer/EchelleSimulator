#ifndef MATRIXSIMULATOR_H
#define MATRIXSIMULATOR_H

#include <memory>
#include "helper.h"
#include "spline.h"
#include "efficiency.h"
#include "source.h"
#include "PSF.h"
#include "CCD.h"
#include "Slit.h"
#include "telescope.h"
#include <array>

/**
 * raw transformation matrix as read from HDF file
 */
struct raw_transformation {
    /// echelle order
    int order;
    /// wavelength [micron]
    double wavelength;
    /// transformation matrix
    std::array<float, 6> transformation_matrix;
    /// transformation matrix decomposed in canonical parameters
    std::vector<float> decomposed_matrix;
};

/**
 * Spectrograph information read from HDF file.
 * Used only for calculating the blaze efficiency curve.
 */
struct spectrograph_information {
    /// blaze angle
    double blaze;
    /// grooves per mm
    double gpmm;
};

typedef struct raw_transformation raw_transformation;

/**
 * \class MatrixSimulator
 * \brief class for simulating spectra
 *
 */
class MatrixSimulator {
public:
    /**
     * Load spectrograph model from HDF file
     * @param path path to HDF file containing spectrograph model
     * @param fiber_number fiber to select
     * @param keep_ccd if true it assumes that a CCD has already been added to the spectrograph model. It keeps it and
     * adds the new simulations to it. This can be used to simplify the simulation of multiple fibers.
     */
    MatrixSimulator(const std::string path, int fiber_number, bool keep_ccd);

    /**
     * Set wavelength grid on which the input spectrum will be interpolated.
     * @param N number of wavelength per order
     */
    void set_wavelength(int N);

    /**
     * Set wavelength grid on which the input spectrum will be evaluated on
     * @param wavelength wavelength vector. Values given in microns.
     */
    void set_wavelength(std::vector<double> wavelength);

    /**
     * Adds an efficiency profile to the simulator.
     * @param eff
     */
    void add_efficiency(Efficiency *eff);

    /**
     * Sets telescope of the spectrograph.
     * @param telescope
     */
    void set_telescope(Telescope *telescope);

    /**
     * Sets the spectral source of the current simulation.
     * @param src
     */
    void set_source(Source *src);

    /**
     * Save simulated spectrum to an HDF file.
     * @param filename filename
     * @param bleed bleed overexposed pixel TODO: not implemented yet
     * @param overwrite True to overwrite existing file TODO: not working yet
     */
    void save_to_hdf(const std::string filename, bool bleed = true, bool overwrite = false);

    /**
     * Save simulated spectrum to a FITS file
     * @param filename filename
     * @param bleed bleed overexposed pixel TODO: not implemented yet
     * @param overwrite set true to overwrite existing file
     */
    void save_to_fits(const std::string filename, bool bleed = true, bool overwrite = false);

    /**
     * Save 1d spectra in fits file.
     * This function saves the 1 dimensional spectrum which was used for the simulation in the fits file.
     * It is therefore a perfectly reduced spectrum.
     * @param filename path to the fits file
     */
    void save_1d_to_fits(const std::string filename);

    /**
     * Returns blaze angle in degrees
     * @return blaze angle
     */
    double get_blaze();

    /**
     * Returns grove lines per mm
     * @return grove lines per mm
     */
    double get_gpmm();

    /**
     * Returns fiber number of current simulation.
     * @return current fiber number
     */
    int get_fiber_number();

    /**
     * Simulate spectrum.
     * @param t integration time
     * @param seed random seed. If 0, will be generated by std::random_device
     * @return
     */
    void simulate(double t, unsigned long seed);

    /**
     * Returns the minimum wavelength supported by the spectrograph [microns]
     * @return minimum wavelength [microns]
     */
    double get_minimum_wavelength();

    /**
    * Returns the maximum wavelength supported by the spectrograph [microns]
    * @return maximum wavelength [microns]
    */
    double get_maximum_wavelength();

    /**
     * Adds readout noise and bias to the frame.
     * Make sure, you only call this function once, when the keep_ccd flag is set.
     *
     * @param bias bias level count
     * @param noise standard deviation for noise
     * @param seed optional: random seed
     */
    void add_background(double bias, double noise, unsigned long seed);

private:
    /**
     * Load spectrograph model from HDF file
     * @param path path to HDF file containing spectrograph model
     * @param fiber_number fiber to select
     * @param keep_ccd if true it assumes that a CCD has already been added to the spectrograph model. It keeps it and
     * adds the new simulations to it. This can be used to simplify the simulation of multiple fibers.
     */
    void load_spectrograph_model(const std::string path, int fiber_number, bool keep_ccd = false);

    /**
     * Calculates spline interpolation functions from matrix elements.
     */
    void calc_splines();

    /**
    * Get affine transformation matrix at specific wavelength and order
    * @param order echelle diffraction order
    * @param wavelength wavelength [micron]
    * @return 2x3 affine transformation matrix
    */
    std::array<float, 6> get_transformation_matrix(int order, double wavelength);

    /**
     * Get affine transformation matrix, but use lookup tables for speedup.
     * In good approximation the parameters shear, rotation, scale_x and scale_y will not vary quickly.
     * Use lookup tables for them for speedup.
     * @param o echelle diffraction order
     * @param wavelength wavelength [micron]
     * @return 2x3 affine transformation matrix
     */
    inline std::array<float, 6> get_transformation_matrix_lookup(int o, double wavelength);

    /**
     *
     * @param efficiencies
     */
    void set_efficiencies(std::vector<Efficiency *> &efficiencies);

//    void set_ccd(CCD *ccd);

//    void set_slit(Slit *slit);

//    void set_psfs(PSF *psfs);

    /**
     * Prepares source to be used for simulation.
     * @param source
     */
    void prepare_source(Source *source);

    /**
     * Prepares PSF models to be used for simulations: pre-calculates N PSF models per order that will be used in a lookup
     * table to speed up computation.
     * @param N number of PSF models per order
     */
    void prepare_psfs(int N);

    /**
     * Generates lookup table for matrix elements.
     * @param N Number of matrix elements per order
     */
    void prepare_matrix_lookup(int N);

    /// Vector containing the used in the simulation
    std::vector<int> orders;
    /// fiber number used in simulation
    int fiber_number;
    /// Length of MatrixSimulation::orders
    int n_orders;
    /// lowest order number
    int min_order;
    // highest order number
    int max_order;
    /// reddest wavelength of spectrograph model
    double wavelength_limit_max = 0.; // will be overwritten by load_spectrograph model
    /// bluest wavelength of spectrograph model
    double wavelength_limit_min = 100.; // will be overwritten by load_spectrograph model
    /// transformation matrices as read in from HDF file
    std::map<int, std::vector<raw_transformation> > raw_transformations;
    /// vectors describing the spectrograph efficiencies
    std::vector<Efficiency *> efficiencies;
    /// vector containing the sources used in the simulation
    Source * source;
    /// Telescope used in the simulation (only used for stellar-type sources when visual magnitude is provided)
    Telescope telescope;
    /// CCD object used in simulation
    CCD *ccd;
    /// PSF model used in simulation
    PSF *psfs;
    /// Slit model used in simulation
    Slit *slit;

    /// Wavelength grid used for interpolation of source spectra
    std::vector<std::vector<double>> sim_wavelength;
    /// Efficiencies used for spectrograph, interpolated on wavelength grid sim_wavelength
    std::vector<std::vector<double>> sim_efficiencies;
    /// Source spectra interpolated on wavelength grid sim_wavelength
    std::vector<std::vector<double>> sim_flux;
    /// Source spectrum times efficiency model on wavelength grid sim_wavelength
    std::vector<std::vector<double>> flux_times_efficiency;
    /// 'total' efficiency per order. Used for calculating number of photons per order.
    std::vector<double> sim_total_efficiency_per_order;
    /// Pre-calculated PSFs, interpolated on sim_psfs_wavelength
    std::vector<std::vector<Matrix>> sim_psfs;
    /// Wavelength of PSFs at which they are interpolated
    std::vector<std::vector<double>> sim_psfs_wavelength;
    /// Distance of consecutive elements of sim_psfs_wavelength
    std::vector<double> sim_psfs_dwavelength;

    /// interpolated values for p, q, r, phi, tx and ty
    std::vector<std::vector<double>> sim_p;
    std::vector<std::vector<double>> sim_q;
    std::vector<std::vector<double>> sim_r;
    std::vector<std::vector<double>> sim_phi;
    std::vector<std::vector<double>> sim_tx;
    std::vector<std::vector<double>> sim_ty;

    /// interpolated matrix values
    std::vector<std::vector<double>> sim_m00;
    std::vector<std::vector<double>> sim_m01;
    std::vector<std::vector<double>> sim_m10;
    std::vector<std::vector<double>> sim_m11;

    /// wavelength of lookup table for matrix elements
    std::vector<std::vector<double>> sim_matrix_wavelength;
    /// Distance of consecutive elements of sim_matrix_wavelength
    std::vector<double> sim_matrix_dwavelength;

    /// spline interpolation functions for p, r, q, phi, tx, ty
    std::vector<tk::spline> tr_p;
    std::vector<tk::spline> tr_r;
    std::vector<tk::spline> tr_q;
    std::vector<tk::spline> tr_phi;
    std::vector<tk::spline> tr_tx;
    std::vector<tk::spline> tr_ty;

    /// spectrograph information
    spectrograph_information spec_info;
};

#endif // MATRIXSIMULATOR_H
